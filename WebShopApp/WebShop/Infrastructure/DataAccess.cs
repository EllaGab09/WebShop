using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using WebShop.Data;
using WebShop.Models;
using WebShop.Models_DbSet;

namespace WebShop.Infrastructure
{
    public class DataAccess : IDataAccess
    {
        private readonly ApplicationDbContext applicationDbContext;

        public DataAccess(ApplicationDbContext applicationDbContext)
        {
            this.applicationDbContext = applicationDbContext;
        }

        public void CreateProduct(Product product)
        {
            //Mappar om, då jag önskar att id automat genereras, kanske finns snyggare implementation, kanske automapper??
            Product test = new Product
            {
                Name = product.Name,
                Price = product.Price,
                ImageUrl = product.ImageUrl,
                DetailedProduct = product.DetailedProduct,
                ProductOrder = product.ProductOrder
            };
            applicationDbContext.Products.Add(test);
            applicationDbContext.SaveChanges();
        }
        public DetailedProduct ReadProduct(Product product)
        {
            var ProductDetails = applicationDbContext.DetailedProducts
                .FirstOrDefault(m => m.ProductIdFK == product.Id);
            return ProductDetails;
        }
        public void UpdateProduct(Product product)
        {
            applicationDbContext.Products.Update(product);
            applicationDbContext.SaveChanges();
        }
        public void DeleteProduct(Product product)
        {
            var ProductToDelete = applicationDbContext.Products
                .FirstOrDefault(m => m.Id == product.Id);
            applicationDbContext.Remove(ProductToDelete);
            applicationDbContext.SaveChanges();

        }
        public List<Product> ReadAllProducts()
        {
            var rows = from row in applicationDbContext.Products select row;
            return rows.ToList();
        }




        public void CreateOrder(DetailedOrder detailedOrder)
        {
            Order order = null;
            order = new Order //Mappar om, då jag önskar att id automat genereras, kanske finns snyggare implementation, kanske automapper??
            {
                Customer = detailedOrder.Order.Customer,
                TotalPrice = detailedOrder.Order.TotalPrice,
                ProductOrder = detailedOrder.Order.ProductOrder
            };
            applicationDbContext.Orders.Add(order);
            applicationDbContext.SaveChanges();
            int AutoGeneratedOrderId = order.Id; //Debug.WriteLine($"Id som just skapats är =  {AutoGeneratedOrderId}"); //Note, im not sure this is the optimal solution, i would prefer to use GUID "Guid id = Guid.NewGuid();", and inject/use it, instead of requesting it.
            AddProductsToOrder(detailedOrder.Products, order.Id);
        }
        //This (public DetailedOrder ReadOrder(Order order)) was a tricky one becouse:
        //A) Its very easy to get serveral db connections open at the same time and thus a runtime error.
        //B) When i try to use "using" to controll the resorces i get a message:  "Cannot access a disposed context instance.A common cause of this error is disposing a context instance that was resolved from dependency injection and then later trying to use the same context instance elsewhere in your application. This may occur if you are calling 'Dispose' on the context instance, or wrapping it in a using statement. If you are using dependency injection, you should let the dependency injection container take care of disposing context instances."
        //THUS I DO MY BEST TO KEEP TRACK OF THE SCOPE OF EACH VARIABLE THAT KEEPS AN OPEN CONNECTION.
        public DetailedOrder ReadOrder(Order order)
        {
            DetailedOrder detailedOrder = new DetailedOrder();

            Debug.WriteLine(" Join 3 tables (Order, ProductOrder, Product) into a 'OrderProductOrderProductCollection' ");
            var OrderProductOrderProductTable = applicationDbContext.Orders //Open connection
                .Join(applicationDbContext.ProductOrder, o => o.Id, po => po.OrderFK, (o, po) => new { o, po })
                .Join(applicationDbContext.Products, JustCreatedAnonomousList => JustCreatedAnonomousList.po.ProductFK, p => p.Id, (JustCreatedAnonomousList, p) => new
                {
                    OrderId = JustCreatedAnonomousList.o.Id,
                    ProductId = p.Id
                });
            var ProductsInOrderList = OrderProductOrderProductTable.Where(a => a.OrderId == order.Id).ToList(); //ToList() => TO CLOSE THE CONNECTION

            IQueryable<Product> ProductRowsInApplicationDbContext = from row in applicationDbContext.Products select row; //open and close connection
            List<Product> ProductsList = new List<Product>();
            foreach (var item in ProductsInOrderList)
            {
                ProductsList.Add(ProductRowsInApplicationDbContext.Where(a => a.Id == item.ProductId).FirstOrDefault()); //open and close connection
            }

            //Assign data and check our detailedOrder
            detailedOrder.Order = applicationDbContext.Orders.FirstOrDefault(o => o.Id == order.Id);
            detailedOrder.Products = ProductsList;
            Debug.WriteLine(ObjectDumper.Dump(detailedOrder));

            return detailedOrder;
        }
        public void UpdateOrder(DetailedOrder detailedOrder)
        {
            ICollection<Product> ProductsInOrderToUpdate = detailedOrder.Products;
            RemoveAllProductsFromOrder(detailedOrder.Order); //Pass by reference.
            AddProductsToOrder(ProductsInOrderToUpdate, detailedOrder.Order.Id);
            applicationDbContext.Orders.Update(detailedOrder.Order); //Order uppdaterar jag, då jag inte vill generera nytt id, vilket görs om jag kör Delete följt av Create.
        }
        public void DeleteOrder(Order order)
        {
            if (applicationDbContext.Orders.Any(e => e == order)) //If i try to remove and item that does not exist we get an error.
            {
                RemoveAllProductsFromOrder(order);
                applicationDbContext.Orders.Remove(order);
                applicationDbContext.SaveChanges();
            }
        }
        public List<Order> ReadAllOrders()
        {
            var rows = from row in applicationDbContext.Orders select row;
            return rows.ToList();
        }


        public void RemoveAllProductsFromOrder(Order order)
        {
            var ProductOrderFKColumn = applicationDbContext.Orders.Join(applicationDbContext.ProductOrder, o => o.Id, po => po.OrderFK, (o, po) => new { OrderFK = po.OrderFK }); //Open connection
            var ProductOrder_OrderFK_ToRemoveList = ProductOrderFKColumn.Where(a => a.OrderFK == order.Id).ToList(); //ToList() => TO CLOSE THE CONNECTION
            IQueryable<ProductOrder> ProductOrderRowsInApplicationDbContext = from row in applicationDbContext.ProductOrder select row; //open and close connection
            foreach (var item in ProductOrder_OrderFK_ToRemoveList)
            {
                ProductOrder ProductOrderToRemove = ProductOrderRowsInApplicationDbContext.Where(a => a.OrderFK == item.OrderFK).FirstOrDefault();
                applicationDbContext.ProductOrder.Remove(ProductOrderToRemove);
                applicationDbContext.SaveChanges();
            }
        }
        public void AddProductsToOrder(ICollection<Product> products, int orderId)
        {
            foreach (var product in products)
            {
                ProductOrder productOrder = new ProductOrder()
                {
                    ProductFK = product.Id,
                    OrderFK = orderId
                };
                applicationDbContext.ProductOrder.Add(productOrder);
                applicationDbContext.SaveChanges();
            }
        }
    }
}
